<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="逍遥很晕"><title>for-of 中为什么可以做异步回调 · 逍遥很晕</title><meta name="description" content="for-of 中为什么可以做异步回调#Iterator#**可迭代协议**：允许js对象去定义它们的迭代行为。为了变成可迭代对象，一个对象必须实现@@iterator 方法，意思是这个对象或者对象的原型上必须要有一个Symbol.iterator的属性
**迭代器协议**：实现Iterator的方式"><meta name="keywords" content="for-of"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.jpeg" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/mg.jpeg" style="width:150px;border-radius: 50%;"><h3 title=""><a href="/">逍遥很晕</a></h3><div class="description"><p>开心了就笑，不开心了就过会再笑~~</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/categories">分类</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>for-of 中为什么可以做异步回调</a></h3><div class="post-other-info"><span class="wordcount"><i class="fa fa-calendar-o"></i><span class="post-count">2019-06-04</span></span><span class="post-meta-divider">|</span><span class="wordcount"><i class="fa fa-folder-o"></i><span class="post-count"><a href="/categories/javascript/" title class="tag">javascript</a></span></span><span class="post-meta-divider">|</span><span class="wordcount"><i class="fa fa-edit"></i><span class="post-count">字数统计1,315</span></span><span class="post-meta-divider">|</span><span class="wordcount"><i class="fa fa-clock-o"></i><span class="post-count">阅读时长5分钟</span></span></div></div><div class="post-content"><h1><span id="for-of-zhong-wei-shi-me-ke-yi-zuo-yi-bu-hui-diao">for-of 中为什么可以做异步回调</span><a href="#for-of-zhong-wei-shi-me-ke-yi-zuo-yi-bu-hui-diao" class="header-anchor">#</a></h1><h1><span id="iterator">Iterator</span><a href="#iterator" class="header-anchor">#</a></h1><p><code>**可迭代协议**</code>：允许js对象去定义它们的迭代行为。为了变成可迭代对象，一个对象必须实现@@iterator 方法，意思是这个对象或者对象的原型上必须要有一个Symbol.iterator的属性</p>
<p><code>**迭代器协议**</code>：实现Iterator的方式：必须要有一个next方法，并且该方法返回一个形如 <code>{value: xx, done: false }</code> 的对象，当迭代器的迭代次数超过了可迭代次数时done为true，value的值可以别省略。</p>
<p>Iterator是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。Iterator本身是符合迭代器协议的。</p>
<p>Iterator的作用主要有三个：</p>
<ol>
<li>为各种数据结构，提供统一、简洁的访问接口</li>
<li>使数据结构的成员能够按照某种次序排列</li>
<li>为ES6中的for…of命令提供接口，供其消费(解构赋值和扩展运算符中也会用到Iterator：[…arr])</li>
</ol>
<p>模拟实现一个简单的Iterator</p>
<pre><code>function iteratorMaker(arr) {
    let nextIndex = 0;
    return function() {
        return nextIndex &lt; arr.length
            ? {value: arr[nextIndex], done: false}
            : {value: undefined, done: true};
    }
}
</code></pre><p>在原生js中，String、Array、TypedArray、Map、Set、Arguments、NodeList对象都有默认的Iterator实现（object对象默认没有实现Iterator，主要是因为默认无法确定遍历的顺序），他们是通过实现Symbol.iterator属性实现的。如果我们想某个对象拥有自定义的Iterator属性，可以通过定义这个对象的Symbol.iterator属性：</p>
<pre><code>const obj = {
    [Symbol.iterator]: function() 
        return {
            next: function() {
                return {
                    value: 1,
                    done: true,
                }
            }
        }
    }
}
</code></pre><h3><span id="bian-li-qi-dui-xiang-de-return-throw-fang-fa">遍历器对象的return()、throw()方法</span><a href="#bian-li-qi-dui-xiang-de-return-throw-fang-fa" class="header-anchor">#</a></h3><p>遍历器中除了具有next方法之外，还可以具有return方法和throw方法。</p>
<p><strong>return方法</strong>：当你的遍历器对象在执行过程中提前退出时(通常是因为出错或者是有break语句)，就会调用return方法，如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。return方法必须返回一个对象。</p>
<pre><code>function readLinesSync(file) {
    return {
        [Symbol.iterator]() {
            return {
                next() {
                    return {done: false, value: 1};
                },
                return() {
                    file.close();
                    return { done: ture}
                }
            }
        }
    }
}
</code></pre><p>throw方法主要配合Generator函数使用，一般的遍历器对象用不到这个方法。</p>
<h2><span id="generator">Generator</span><a href="#generator" class="header-anchor">#</a></h2><p>语法：</p>
<pre><code>function* generator() {
    var a = &#39;hello&#39;;
    yield a;
    yield &#39;world&#39;;
}
var a = generator();
a.next(); // { value: &#39;hello&#39;, done: false}
a.next(); // { value: &#39;world&#39;, done: false}
a.next(); // { value: undefined, done: true}
</code></pre><p>在调用generator的时候，其函数体并不立即执行，而是会返回一个遍历器iterator对象，当你执行遍历器对象的next方法的时候，才会真正执行generator方法体内部的内容。</p>
<p>当执行next的方法的时候，在函数体内遇到yield的时候，函数体将停止执行并将yield后的结果值返回出来(也就是next的执行结果，形如：{value:xxx,done: false})，直到下一个next方法被调用时才会从上次停止的位置继续向下执行。</p>
<blockquote>
<p>yield表达式本身没有返回值，但是next方法可以带一个参数，这个参数会被当做上一个yield表达式的返回值。这里需要注意的是第一次调用next方法时，传入的参数是无效的，因为它之前并没有yield方法。</p>
</blockquote>
<p>举个栗子🌰：</p>
<pre><code>function* foo(x) {
  console.log(&#39;第一个:&#39;, &#39; x:&#39;, x);
  var y = 2 * (yield (x + 1));
  console.log(&#39;第二个:&#39;, &#39; x:&#39;, x , &#39; y:&#39;, y);
  var z = yield (y / 3);
  console.log(&#39;第三个:&#39;, &#39; x:&#39;, x, &#39; y:&#39;, y, &#39; z:&#39;, z);
  return (x + y + z);
}

var a = foo(5); // 返回一个generator对象

a.next(10);
// console.log输出：第一个:  x: 5，因为这是第一个执行的next方法，它之前并没有yield语句
// 返回的值为：{value: 6, done: false}

a.next(11);
// console.log输出：第二个:  x: 5  y: 22，11被当成上一个yield表达式的结果，即：var y = 2 * 11
// 返回的值为：{value: 7.333333333333333, done: false}

a.next(12);
// console.log输出：第三个:  x: 5  y: 22  z: 12，道理同上
// 返回的值为：{value: 39, done: true}

a.next(); // {value: undefined, done: true}
</code></pre><p>Generator的其他内容强烈建议阅读：<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">阮一峰的Generator 函数的语法</a>，里面内容很多。</p>
<h1><span id="for-of">for-of</span><a href="#for-of" class="header-anchor">#</a></h1><p>在ES6中，js借鉴C++、Java等语言，引入了for…of循环，作为便利所有数据结构的统一方法。一个数据结构只要部署了Symbol.iterator属性，就被视为具有Iterator接口，就可以使用for…of循环进行遍历，也就是说for…of循环内部调用的是数据结构的Symbol.iterator方法，这就为我们在for…of内进行异步调用提供了可能。</p>
<p>for-of方法可以自动遍历Generator函数运行时生成的Iterator对象，且此时不在需要next方法。</p>
<h1><span id="yu-for-in-qu-bie">与for-in区别</span><a href="#yu-for-in-qu-bie" class="header-anchor">#</a></h1><p>for…in只能获取键名，for…of可以获取键值 </p>
<p>let arr = [1,2,3]; <a href="http://arr.foo" target="_blank" rel="noopener">arr.foo</a> = ‘hello’; for…in 循环arr的结果：0,1,2,hello，for…of循环arr的结果：1,2,3。可以看出for…of循环数组只会遍历有数字索引的属性。</p>
<p>for…of支持异步调用</p>
<p>for…in 循环会循环原型链上的键</p>
<p>参考：</p>
<p>迭代协议：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols</a></p>
<p>Generator 函数的语法：<a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/iterator</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-06-04</span><i class="fa fa-tag"></i><a href="/tags/for-of/" title="for-of" class="tag">for-of </a><a href="/tags/javascript/" title="javascript" class="tag">javascript </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://happybug.top/2019/06/04/for-of/,逍遥很晕,for-of 中为什么可以做异步回调,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2019/06/04/BFC/" title="BFC" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2019/05/20/module/" title="JS中的模块化" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7b168a4f1a257e5aaf73660ae4ffad1c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></body></html>